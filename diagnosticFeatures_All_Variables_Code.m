
diagnosticFeatures_altitude_linAccy(dataTable)

function [featureTable,outputTable] = diagnosticFeatures_altitude_linAccy(inputData)
%DIAGNOSTICFEATURES recreates results in Diagnostic Feature Designer.
%
% Input:
%  inputData: A table or a cell array of tables/matrices containing the
%  data as those imported into the app.
%
% Output:
%  featureTable: A table containing all features and condition variables.
%  outputTable: A table containing the computation results.
%
% This function computes spectra:
%  altitudeTT_ps/SpectrumData
%  linAcc_yTT_ps/SpectrumData
%
% This function computes features:
%  altitudeTT_sigstats/ClearanceFactor
%  altitudeTT_sigstats/CrestFactor
%  altitudeTT_sigstats/ImpulseFactor
%  altitudeTT_sigstats/Kurtosis
%  altitudeTT_sigstats/Mean
%  altitudeTT_sigstats/PeakValue
%  altitudeTT_sigstats/RMS
%  altitudeTT_sigstats/ShapeFactor
%  altitudeTT_sigstats/Skewness
%  altitudeTT_sigstats/Std
%  altitudeTT_ps_spec/PeakAmp1
%  altitudeTT_ps_spec/PeakAmp2
%  altitudeTT_ps_spec/PeakFreq1
%  altitudeTT_ps_spec/PeakFreq2
%  altitudeTT_ps_spec/BandPower
%  linAcc_yTT_sigstats/ClearanceFactor
%  linAcc_yTT_sigstats/CrestFactor
%  linAcc_yTT_sigstats/ImpulseFactor
%  linAcc_yTT_sigstats/Kurtosis
%  linAcc_yTT_sigstats/Mean
%  linAcc_yTT_sigstats/PeakValue
%  linAcc_yTT_sigstats/RMS
%  linAcc_yTT_sigstats/ShapeFactor
%  linAcc_yTT_sigstats/Skewness
%  linAcc_yTT_sigstats/Std
%  linAcc_yTT_ps_spec/PeakAmp1
%  linAcc_yTT_ps_spec/PeakAmp2
%  linAcc_yTT_ps_spec/PeakFreq1
%  linAcc_yTT_ps_spec/PeakFreq2
%  linAcc_yTT_ps_spec/BandPower
%
% Frame Policy:
%  Frame name: FRM_1
%  Frame size: 20 seconds
%  Frame rate: 20 seconds
%
% Organization of the function:
% 1. Compute signals/spectra/features
% 2. Extract computed features into a table
%
% Modify the function to add or remove data processing, feature generation
% or ranking operations.

% Auto-generated by MATLAB on 04-Apr-2023 17:07:09

% Create output ensemble.
outputEnsemble = workspaceEnsemble(inputData,'DataVariables',["linAcc_xTT";"linAcc_yTT";"linAcc_zTT";"angVel_xTT";"angVel_yTT";"angVel_zTT";"errVel_xTT";"errVel_yTT";"errVel_zTT";"altitudeTT";"latitudeTT";"longitudeTT";"err_roll_TT";"err_airspeed_TT";"aspd_error_TT";"alt_error_TT";"err_yaw_TT";"err_pitch_TT"],'ConditionVariables',"FaultLabel");

% Reset the ensemble to read from the beginning of the ensemble.
reset(outputEnsemble);

% Append new frame policy name to DataVariables.
outputEnsemble.DataVariables = [outputEnsemble.DataVariables;"FRM_1"];

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = ["linAcc_xTT";"linAcc_yTT";"linAcc_zTT";"angVel_xTT";"angVel_yTT";"angVel_zTT";"errVel_xTT";"errVel_yTT";"errVel_zTT";"altitudeTT";"latitudeTT";"longitudeTT";"err_roll_TT";"err_airspeed_TT";"aspd_error_TT";"alt_error_TT";"err_yaw_TT";"err_pitch_TT"];

% Loop through all ensemble members to read and write data.
while hasdata(outputEnsemble)
    % Read one member.
    member = read(outputEnsemble);

    % Read signals.
    linAcc_xTT_full = readMemberData(member,"linAcc_xTT",["Time","Var1"]);
    linAcc_yTT_full = readMemberData(member,"linAcc_yTT",["Time","Var1"]);
    linAcc_zTT_full = readMemberData(member,"linAcc_zTT",["Time","Var1"]);

    angVel_xTT_full = readMemberData(member,"angVel_xTT",["Time","Var1"]);
    angVel_yTT_full = readMemberData(member,"angVel_yTT",["Time","Var1"]);
    angVel_zTT_full = readMemberData(member,"angVel_zTT",["Time","Var1"]);

    errVel_xTT_full = readMemberData(member,"errVel_xTT",["Time","Var1"]);
    errVel_yTT_full = readMemberData(member,"errVel_yTT",["Time","Var1"]);
    errVel_zTT_full = readMemberData(member,"errVel_zTT",["Time","Var1"]);

    altitudeTT_full = readMemberData(member,"altitudeTT",["Time","Var1"]);
    latitudeTT_full = readMemberData(member,"latitudeTT",["Time","Var1"]);
    longitudeTT_full = readMemberData(member,"longitudeTT",["Time","Var1"]);


    err_roll_TT_full = readMemberData(member,"err_roll_TT",["Time","Var1"]);
    err_airspeed_TT_full = readMemberData(member,"err_airspeed_TT",["Time","Var1"]);
    aspd_error_TT_full = readMemberData(member,"aspd_error_TT",["Time","Var1"]);
    alt_error_TT_full = readMemberData(member,"alt_error_TT",["Time","Var1"]);
    err_yaw_TT_full = readMemberData(member,"err_yaw_TT",["Time","Var1"]);
    err_pitch_TT_full = readMemberData(member,"err_pitch_TT",["Time","Var1"]);
    



    % Get the frame intervals.
    lowerBound = min([linAcc_yTT_full.Time(1), linAcc_yTT_full.Time(1), linAcc_zTT_full.Time(1), angVel_xTT_full.Time(1), angVel_yTT_full.Time(1), angVel_zTT_full.Time(1), errVel_xTT_full.Time(1), errVel_yTT_full.Time(1), errVel_zTT_full.Time(1), altitudeTT_full.Time(1), latitudeTT_full.Time(1), longitudeTT_full.Time(1),  err_roll_TT_full.Time(1), err_airspeed_TT_full.Time(1), aspd_error_TT_full.Time(1), alt_error_TT_full.Time(1), err_yaw_TT_full.Time(1), err_pitch_TT_full.Time(1)]);
    upperBound = max([linAcc_yTT_full.Time(end), linAcc_yTT_full.Time(end), linAcc_zTT_full.Time(end), angVel_xTT_full.Time(end), angVel_yTT_full.Time(end), angVel_zTT_full.Time(end), errVel_xTT_full.Time(end), errVel_yTT_full.Time(end), errVel_zTT_full.Time(end), altitudeTT_full.Time(end), latitudeTT_full.Time(end), longitudeTT_full.Time(end),  err_roll_TT_full.Time(end), err_airspeed_TT_full.Time(end), aspd_error_TT_full.Time(end), alt_error_TT_full.Time(end), err_yaw_TT_full.Time(end), err_pitch_TT_full.Time(end)]);
    fullIntervals = frameintervals([lowerBound upperBound],20,20,'FrameUnit',"seconds");
    intervals = fullIntervals;

    % Initialize a table to store frame results.
    frames = table;



    % Loop through all frame intervals and compute results.
    for ct = 1:height(intervals)
        % Get all input variables.
        
        linAcc_xTT = linAcc_xTT_full(linAcc_xTT_full.Time>=intervals{ct,1}&linAcc_xTT_full.Time<intervals{ct,2},:);
        linAcc_yTT = linAcc_yTT_full(linAcc_yTT_full.Time>=intervals{ct,1}&linAcc_yTT_full.Time<intervals{ct,2},:);
        linAcc_zTT = linAcc_zTT_full(linAcc_zTT_full.Time>=intervals{ct,1}&linAcc_zTT_full.Time<intervals{ct,2},:);

        angVel_xTT = angVel_xTT_full(angVel_xTT_full.Time>=intervals{ct,1}&angVel_xTT_full.Time<intervals{ct,2},:);
        angVel_yTT = angVel_yTT_full(angVel_yTT_full.Time>=intervals{ct,1}&angVel_yTT_full.Time<intervals{ct,2},:);
        angVel_zTT = angVel_zTT_full(angVel_zTT_full.Time>=intervals{ct,1}&angVel_zTT_full.Time<intervals{ct,2},:);

        errVel_xTT = errVel_xTT_full(errVel_xTT_full.Time>=intervals{ct,1}&errVel_xTT_full.Time<intervals{ct,2},:);
        errVel_yTT = errVel_yTT_full(errVel_yTT_full.Time>=intervals{ct,1}&errVel_yTT_full.Time<intervals{ct,2},:);
        errVel_zTT = errVel_zTT_full(errVel_zTT_full.Time>=intervals{ct,1}&errVel_zTT_full.Time<intervals{ct,2},:);
        

        altitudeTT = altitudeTT_full(altitudeTT_full.Time>=intervals{ct,1}&altitudeTT_full.Time<intervals{ct,2},:);
        latitudeTT = latitudeTT_full(latitudeTT_full.Time>=intervals{ct,1}&latitudeTT_full.Time<intervals{ct,2},:);
        longitudeTT = longitudeTT_full(longitudeTT_full.Time>=intervals{ct,1}&longitudeTT_full.Time<intervals{ct,2},:);



        err_roll_TT = err_roll_TT_full(err_roll_TT_full.Time>=intervals{ct,1}&err_roll_TT_full.Time<intervals{ct,2},:);
        err_airspeed_TT = err_airspeed_TT_full(err_airspeed_TT_full.Time>=intervals{ct,1}&err_airspeed_TT_full.Time<intervals{ct,2},:);
        aspd_error_TT = aspd_error_TT_full(aspd_error_TT_full.Time>=intervals{ct,1}&aspd_error_TT_full.Time<intervals{ct,2},:);
        alt_error_TT = alt_error_TT_full(alt_error_TT_full.Time>=intervals{ct,1}&alt_error_TT_full.Time<intervals{ct,2},:);
        err_yaw_TT = err_yaw_TT_full(err_yaw_TT_full.Time>=intervals{ct,1}&err_yaw_TT_full.Time<intervals{ct,2},:);
        err_pitch_TT = err_pitch_TT_full(err_pitch_TT_full.Time>=intervals{ct,1}&err_pitch_TT_full.Time<intervals{ct,2},:);


        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



        % Initialize a table to store results for one frame interval.
        frame = intervals(ct,:);



        %% PowerSpectrum - linAcc_x
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(linAcc_xTT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = linAcc_xTT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            linAcc_xTT_ps = ps;
        catch
            linAcc_xTT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({linAcc_xTT_ps},'VariableNames',"linAcc_xTT_ps")];

        %% SignalFeatures - linAcc_x
        try
            % Compute signal features.
            inputSignal = linAcc_xTT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            linAcc_xTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            linAcc_xTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({linAcc_xTT_sigstats},'VariableNames',"linAcc_xTT_sigstats")];

        %% SpectrumFeatures - linAcc_x
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = linAcc_xTT_ps.SpectrumData;
            w = linAcc_xTT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            linAcc_xTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            linAcc_xTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({linAcc_xTT_ps_spec},'VariableNames',"linAcc_xTT_ps_spec")];

        

%----------------------------------------------------------------------------------------------
        %% PowerSpectrum - linAcc_y
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(linAcc_yTT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = linAcc_yTT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            linAcc_yTT_ps = ps;
        catch
            linAcc_yTT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({linAcc_yTT_ps},'VariableNames',"linAcc_yTT_ps")];

        %% SignalFeatures - linAcc_y
        try
            % Compute signal features.
            inputSignal = linAcc_yTT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            linAcc_yTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            linAcc_yTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({linAcc_yTT_sigstats},'VariableNames',"linAcc_yTT_sigstats")];

        %% SpectrumFeatures - linAcc_y
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = linAcc_yTT_ps.SpectrumData;
            w = linAcc_yTT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            linAcc_yTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            linAcc_yTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({linAcc_yTT_ps_spec},'VariableNames',"linAcc_yTT_ps_spec")];

%--------------------------------------------------------------


        %% PowerSpectrum - linAcc_z
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(linAcc_zTT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = linAcc_zTT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            linAcc_zTT_ps = ps;
        catch
            linAcc_zTT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({linAcc_zTT_ps},'VariableNames',"linAcc_zTT_ps")];

        %% SignalFeatures - linAcc_z
        try
            % Compute signal features.
            inputSignal = linAcc_zTT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            linAcc_zTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            linAcc_zTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({linAcc_zTT_sigstats},'VariableNames',"linAcc_zTT_sigstats")];

        %% SpectrumFeatures - linAcc_z
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = linAcc_zTT_ps.SpectrumData;
            w = linAcc_zTT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            linAcc_zTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            linAcc_zTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({linAcc_zTT_ps_spec},'VariableNames',"linAcc_zTT_ps_spec")];


        %------------------------------------------------------------------------------------


        %% PowerSpectrum - angVel_x
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(angVel_xTT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = angVel_xTT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            angVel_xTT_ps = ps;
        catch
            angVel_xTT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({angVel_xTT_ps},'VariableNames',"angVel_xTT_ps")];

        %% SignalFeatures - angVel_x
        try
            % Compute signal features.
            inputSignal = angVel_xTT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            angVel_xTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            angVel_xTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({angVel_xTT_sigstats},'VariableNames',"angVel_xTT_sigstats")];

        %% SpectrumFeatures - angVel_x
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = angVel_xTT_ps.SpectrumData;
            w = angVel_xTT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            angVel_xTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            angVel_xTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({angVel_xTT_ps_spec},'VariableNames',"angVel_xTT_ps_spec")];


        %-----------------------------------------------------------------------------------

        %% PowerSpectrum - angVel_y
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(angVel_yTT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = angVel_yTT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            angVel_yTT_ps = ps;
        catch
            angVel_yTT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({angVel_yTT_ps},'VariableNames',"angVel_yTT_ps")];

        %% SignalFeatures - angVel_y
        try
            % Compute signal features.
            inputSignal = angVel_yTT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            angVel_yTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            angVel_yTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({angVel_yTT_sigstats},'VariableNames',"angVel_yTT_sigstats")];

        %% SpectrumFeatures - angVel_y
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = angVel_yTT_ps.SpectrumData;
            w = angVel_yTT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            angVel_yTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            angVel_yTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({angVel_yTT_ps_spec},'VariableNames',"angVel_yTT_ps_spec")];



        %--------------------------------------------------------------------


        %% PowerSpectrum - angVel_z
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(angVel_zTT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = angVel_zTT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            angVel_zTT_ps = ps;
        catch
            angVel_zTT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({angVel_zTT_ps},'VariableNames',"angVel_zTT_ps")];

        %% SignalFeatures - angVel_z
        try
            % Compute signal features.
            inputSignal = angVel_zTT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            angVel_zTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            angVel_zTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({angVel_zTT_sigstats},'VariableNames',"angVel_zTT_sigstats")];

        %% SpectrumFeatures - angVel_z
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = angVel_zTT_ps.SpectrumData;
            w = angVel_zTT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            angVel_zTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            angVel_zTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({angVel_zTT_ps_spec},'VariableNames',"angVel_zTT_ps_spec")];




        %--------------------------------------------------------------------


        %% PowerSpectrum - errVel_xTT
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(errVel_xTT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = errVel_xTT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            errVel_xTT_ps = ps;
        catch
            errVel_xTT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({errVel_xTT_ps},'VariableNames',"errVel_xTT_ps")];

        %% SignalFeatures - errVel_xTT
        try
            % Compute signal features.
            inputSignal = errVel_xTT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            errVel_xTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            errVel_xTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({errVel_xTT_sigstats},'VariableNames',"errVel_xTT_sigstats")];

        %% SpectrumFeatures - errVel_xTT
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = errVel_xTT_ps.SpectrumData;
            w = errVel_xTT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            errVel_xTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            errVel_xTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({errVel_xTT_ps_spec},'VariableNames',"errVel_xTT_ps_spec")];




        %--------------------------------------------------------------------

        %% PowerSpectrum - errVel_yTT
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(errVel_yTT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = errVel_yTT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            errVel_yTT_ps = ps;
        catch
            errVel_yTT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({errVel_yTT_ps},'VariableNames',"errVel_yTT_ps")];

        %% SignalFeatures - errVel_yTT
        try
            % Compute signal features.
            inputSignal = errVel_yTT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            errVel_yTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            errVel_yTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({errVel_yTT_sigstats},'VariableNames',"errVel_yTT_sigstats")];

        %% SpectrumFeatures - errVel_yTT
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = errVel_yTT_ps.SpectrumData;
            w = errVel_yTT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            errVel_yTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            errVel_yTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({errVel_yTT_ps_spec},'VariableNames',"errVel_yTT_ps_spec")];



        %--------------------------------------------------------------------

        %% PowerSpectrum - errVel_zTT
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(errVel_zTT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = errVel_zTT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            errVel_zTT_ps = ps;
        catch
            errVel_zTT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({errVel_zTT_ps},'VariableNames',"errVel_zTT_ps")];

        %% SignalFeatures - errVel_zTT
        try
            % Compute signal features.
            inputSignal = errVel_zTT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            errVel_zTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            errVel_zTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({errVel_zTT_sigstats},'VariableNames',"errVel_zTT_sigstats")];

        %% SpectrumFeatures - errVel_zTT
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = errVel_zTT_ps.SpectrumData;
            w = errVel_zTT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            errVel_zTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            errVel_zTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({errVel_zTT_ps_spec},'VariableNames',"errVel_zTT_ps_spec")];







        %--------------------------------------------------------------------

        %% PowerSpectrum - altitudeTT
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(altitudeTT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = altitudeTT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            altitudeTT_ps = ps;
        catch
            altitudeTT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({altitudeTT_ps},'VariableNames',"altitudeTT_ps")];

        %% SignalFeatures - altitudeTT
        try
            % Compute signal features.
            inputSignal = altitudeTT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            altitudeTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            altitudeTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({altitudeTT_sigstats},'VariableNames',"altitudeTT_sigstats")];

        %% SpectrumFeatures - altitudeTT
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = altitudeTT_ps.SpectrumData;
            w = altitudeTT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            altitudeTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            altitudeTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({altitudeTT_ps_spec},'VariableNames',"altitudeTT_ps_spec")];





        %---------------------------------------------------------------------




        %% PowerSpectrum - latitudeTT
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(latitudeTT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = latitudeTT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            latitudeTT_ps = ps;
        catch
            latitudeTT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({latitudeTT_ps},'VariableNames',"latitudeTT_ps")];

        %% SignalFeatures - latitudeTT
        try
            % Compute signal features.
            inputSignal = latitudeTT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            latitudeTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            latitudeTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({latitudeTT_sigstats},'VariableNames',"latitudeTT_sigstats")];

        %% SpectrumFeatures - latitudeTT
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = latitudeTT_ps.SpectrumData;
            w = latitudeTT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            latitudeTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            latitudeTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({latitudeTT_ps_spec},'VariableNames',"latitudeTT_ps_spec")];


%-----------------------------------------------------------------------------


        %% PowerSpectrum - longitudeTT
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(longitudeTT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = longitudeTT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            longitudeTT_ps = ps;
        catch
            longitudeTT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({longitudeTT_ps},'VariableNames',"longitudeTT_ps")];

        %% SignalFeatures - longitudeTT
        try
            % Compute signal features.
            inputSignal = longitudeTT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            longitudeTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            longitudeTT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({longitudeTT_sigstats},'VariableNames',"longitudeTT_sigstats")];

        %% SpectrumFeatures - longitudeTT
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = longitudeTT_ps.SpectrumData;
            w = longitudeTT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            longitudeTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            longitudeTT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({longitudeTT_ps_spec},'VariableNames',"longitudeTT_ps_spec")];



        %-----------------------------------------------------------------------------

        %% PowerSpectrum - err_roll_TT
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(err_roll_TT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = err_roll_TT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            err_roll_TT_ps = ps;
        catch
            err_roll_TT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({err_roll_TT_ps},'VariableNames',"err_roll_TT_ps")];

        %% SignalFeatures - err_roll_TT
        try
            % Compute signal features.
            inputSignal = err_roll_TT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            err_roll_TT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            err_roll_TT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({err_roll_TT_sigstats},'VariableNames',"err_roll_TT_sigstats")];

        %% SpectrumFeatures - err_roll_TT
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = err_roll_TT_ps.SpectrumData;
            w = err_roll_TT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            err_roll_TT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            err_roll_TT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({err_roll_TT_ps_spec},'VariableNames',"err_roll_TT_ps_spec")];



        %-----------------------------------------------------------------------------


        %% PowerSpectrum - err_airspeed_TT
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(err_airspeed_TT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = err_airspeed_TT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            err_airspeed_TT_ps = ps;
        catch
            err_airspeed_TT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({err_airspeed_TT_ps},'VariableNames',"err_airspeed_TT_ps")];

        %% SignalFeatures - err_airspeed_TT
        try
            % Compute signal features.
            inputSignal = err_airspeed_TT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            err_airspeed_TT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            err_airspeed_TT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({err_airspeed_TT_sigstats},'VariableNames',"err_airspeed_TT_sigstats")];

        %% SpectrumFeatures - err_airspeed_TT
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = err_airspeed_TT_ps.SpectrumData;
            w = err_airspeed_TT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            err_airspeed_TT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            err_airspeed_TT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({err_airspeed_TT_ps_spec},'VariableNames',"err_airspeed_TT_ps_spec")];

        

        %-----------------------------------------------------------------------------

        %% PowerSpectrum - aspd_error_TT
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(aspd_error_TT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = aspd_error_TT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            aspd_error_TT_ps = ps;
        catch
            aspd_error_TT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({aspd_error_TT_ps},'VariableNames',"aspd_error_TT_ps")];

        %% SignalFeatures - aspd_error_TT
        try
            % Compute signal features.
            inputSignal = aspd_error_TT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            aspd_error_TT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            aspd_error_TT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({aspd_error_TT_sigstats},'VariableNames',"aspd_error_TT_sigstats")];

        %% SpectrumFeatures - aspd_error_TT
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = aspd_error_TT_ps.SpectrumData;
            w = aspd_error_TT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            aspd_error_TT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            aspd_error_TT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({aspd_error_TT_ps_spec},'VariableNames',"aspd_error_TT_ps_spec")];




        %-----------------------------------------------------------------------------
        
        %% PowerSpectrum - alt_error_TT
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(alt_error_TT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = alt_error_TT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            alt_error_TT_ps = ps;
        catch
            alt_error_TT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({alt_error_TT_ps},'VariableNames',"alt_error_TT_ps")];

        %% SignalFeatures - alt_error_TT
        try
            % Compute signal features.
            inputSignal = alt_error_TT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            alt_error_TT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            alt_error_TT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({alt_error_TT_sigstats},'VariableNames',"alt_error_TT_sigstats")];

        %% SpectrumFeatures - alt_error_TT
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = alt_error_TT_ps.SpectrumData;
            w = alt_error_TT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            alt_error_TT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            alt_error_TT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({alt_error_TT_ps_spec},'VariableNames',"alt_error_TT_ps_spec")];




        %----------------------------------------------------------------------------
 
        %% PowerSpectrum - err_yaw_TT
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(err_yaw_TT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = err_yaw_TT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            err_yaw_TT_ps = ps;
        catch
            err_yaw_TT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({err_yaw_TT_ps},'VariableNames',"err_yaw_TT_ps")];

        %% SignalFeatures - err_yaw_TT
        try
            % Compute signal features.
            inputSignal = err_yaw_TT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            err_yaw_TT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            err_yaw_TT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({err_yaw_TT_sigstats},'VariableNames',"err_yaw_TT_sigstats")];

        %% SpectrumFeatures - err_yaw_TT
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = err_yaw_TT_ps.SpectrumData;
            w = err_yaw_TT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            err_yaw_TT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            err_yaw_TT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({err_yaw_TT_ps_spec},'VariableNames',"err_yaw_TT_ps_spec")];



        %----------------------------------------------------------------------------

        %% PowerSpectrum - err_pitch_TT
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(err_pitch_TT.Time,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x = err_pitch_TT.Var1;
            if irregular
                x = resample(x,tNumeric,Fs,'linear');
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,12,arOpt);

            % Compute the power spectrum.
            f = linspace(0,12.5,1000);
            f = f*funitconv('Hz','cycles/TimeUnit','seconds');
            [ps,w] = spectrum(model,2*pi*f);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
            ps.Properties.VariableUnits = ["Hz", ""];
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            err_pitch_TT_ps = ps;
        catch
            err_pitch_TT_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({err_pitch_TT_ps},'VariableNames',"err_pitch_TT_ps")];

        %% SignalFeatures - err_pitch_TT
        try
            % Compute signal features.
            inputSignal = err_pitch_TT.Var1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,ShapeFactor,Skewness,Std];

            % Package computed features into a table.
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            err_pitch_TT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,10);
            featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","ShapeFactor","Skewness","Std"];
            err_pitch_TT_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({err_pitch_TT_sigstats},'VariableNames',"err_pitch_TT_sigstats")];

        %% SpectrumFeatures - err_pitch_TT
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = err_pitch_TT_ps.SpectrumData;
            w = err_pitch_TT_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*1) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',2);
            peakAmp = [peakAmp(:); NaN(2-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(2-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakAmp2 = peakAmp(2);
            PeakFreq1 = peakFreq(1);
            PeakFreq2 = peakFreq(2);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakAmp2,PeakFreq1,PeakFreq2,BandPower];

            % Package computed features into a table.
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            err_pitch_TT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Package computed features into a table.
            featureValues = NaN(1,5);
            featureNames = ["PeakAmp1","PeakAmp2","PeakFreq1","PeakFreq2","BandPower"];
            err_pitch_TT_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({err_pitch_TT_ps_spec},'VariableNames',"err_pitch_TT_ps_spec")];



        %----------------------------------------------------------------------------

        %Fino a qui




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


        %% Concatenate frames.
        frames = [frames;frame]; %#ok<*AGROW>
    end

    % Write all the results for the current member to the ensemble.
    memberResult = table({frames},'VariableNames',"FRM_1");
    writeToLastMemberRead(outputEnsemble,memberResult)
end

% Gather all features into a table.
selectedFeatureNames = [
    


"FRM_1/linAcc_xTT_sigstats/ClearanceFactor","FRM_1/linAcc_xTT_sigstats/CrestFactor","FRM_1/linAcc_xTT_sigstats/ImpulseFactor","FRM_1/linAcc_xTT_sigstats/Kurtosis","FRM_1/linAcc_xTT_sigstats/Mean","FRM_1/linAcc_xTT_sigstats/PeakValue","FRM_1/linAcc_xTT_sigstats/RMS","FRM_1/linAcc_xTT_sigstats/ShapeFactor","FRM_1/linAcc_xTT_sigstats/Skewness","FRM_1/linAcc_xTT_sigstats/Std","FRM_1/linAcc_xTT_ps_spec/PeakAmp1","FRM_1/linAcc_xTT_ps_spec/PeakAmp2","FRM_1/linAcc_xTT_ps_spec/PeakFreq1","FRM_1/linAcc_xTT_ps_spec/PeakFreq2","FRM_1/linAcc_xTT_ps_spec/BandPower",...
"FRM_1/linAcc_yTT_sigstats/ClearanceFactor","FRM_1/linAcc_yTT_sigstats/CrestFactor","FRM_1/linAcc_yTT_sigstats/ImpulseFactor","FRM_1/linAcc_yTT_sigstats/Kurtosis","FRM_1/linAcc_yTT_sigstats/Mean","FRM_1/linAcc_yTT_sigstats/PeakValue","FRM_1/linAcc_yTT_sigstats/RMS","FRM_1/linAcc_yTT_sigstats/ShapeFactor","FRM_1/linAcc_yTT_sigstats/Skewness","FRM_1/linAcc_yTT_sigstats/Std","FRM_1/linAcc_yTT_ps_spec/PeakAmp1","FRM_1/linAcc_yTT_ps_spec/PeakAmp2","FRM_1/linAcc_yTT_ps_spec/PeakFreq1","FRM_1/linAcc_yTT_ps_spec/PeakFreq2","FRM_1/linAcc_yTT_ps_spec/BandPower",...
"FRM_1/linAcc_zTT_sigstats/ClearanceFactor","FRM_1/linAcc_zTT_sigstats/CrestFactor","FRM_1/linAcc_zTT_sigstats/ImpulseFactor","FRM_1/linAcc_zTT_sigstats/Kurtosis","FRM_1/linAcc_zTT_sigstats/Mean","FRM_1/linAcc_zTT_sigstats/PeakValue","FRM_1/linAcc_zTT_sigstats/RMS","FRM_1/linAcc_zTT_sigstats/ShapeFactor","FRM_1/linAcc_zTT_sigstats/Skewness","FRM_1/linAcc_zTT_sigstats/Std","FRM_1/linAcc_zTT_ps_spec/PeakAmp1","FRM_1/linAcc_zTT_ps_spec/PeakAmp2","FRM_1/linAcc_zTT_ps_spec/PeakFreq1","FRM_1/linAcc_zTT_ps_spec/PeakFreq2","FRM_1/linAcc_zTT_ps_spec/BandPower", ...
"FRM_1/angVel_xTT_sigstats/ClearanceFactor","FRM_1/angVel_xTT_sigstats/CrestFactor","FRM_1/angVel_xTT_sigstats/ImpulseFactor","FRM_1/angVel_xTT_sigstats/Kurtosis","FRM_1/angVel_xTT_sigstats/Mean","FRM_1/angVel_xTT_sigstats/PeakValue","FRM_1/angVel_xTT_sigstats/RMS","FRM_1/angVel_xTT_sigstats/ShapeFactor","FRM_1/angVel_xTT_sigstats/Skewness","FRM_1/angVel_xTT_sigstats/Std","FRM_1/angVel_xTT_ps_spec/PeakAmp1","FRM_1/angVel_xTT_ps_spec/PeakAmp2","FRM_1/angVel_xTT_ps_spec/PeakFreq1","FRM_1/angVel_xTT_ps_spec/PeakFreq2","FRM_1/angVel_xTT_ps_spec/BandPower",...
"FRM_1/angVel_yTT_sigstats/ClearanceFactor","FRM_1/angVel_yTT_sigstats/CrestFactor","FRM_1/angVel_yTT_sigstats/ImpulseFactor","FRM_1/angVel_yTT_sigstats/Kurtosis","FRM_1/angVel_yTT_sigstats/Mean","FRM_1/angVel_yTT_sigstats/PeakValue","FRM_1/angVel_yTT_sigstats/RMS","FRM_1/angVel_yTT_sigstats/ShapeFactor","FRM_1/angVel_yTT_sigstats/Skewness","FRM_1/angVel_yTT_sigstats/Std","FRM_1/angVel_yTT_ps_spec/PeakAmp1","FRM_1/angVel_yTT_ps_spec/PeakAmp2","FRM_1/angVel_yTT_ps_spec/PeakFreq1","FRM_1/angVel_yTT_ps_spec/PeakFreq2","FRM_1/angVel_yTT_ps_spec/BandPower",...
"FRM_1/angVel_zTT_sigstats/ClearanceFactor","FRM_1/angVel_zTT_sigstats/CrestFactor","FRM_1/angVel_zTT_sigstats/ImpulseFactor","FRM_1/angVel_zTT_sigstats/Kurtosis","FRM_1/angVel_zTT_sigstats/Mean","FRM_1/angVel_zTT_sigstats/PeakValue","FRM_1/angVel_zTT_sigstats/RMS","FRM_1/angVel_zTT_sigstats/ShapeFactor","FRM_1/angVel_zTT_sigstats/Skewness","FRM_1/angVel_zTT_sigstats/Std","FRM_1/angVel_zTT_ps_spec/PeakAmp1","FRM_1/angVel_zTT_ps_spec/PeakAmp2","FRM_1/angVel_zTT_ps_spec/PeakFreq1","FRM_1/angVel_zTT_ps_spec/PeakFreq2","FRM_1/angVel_zTT_ps_spec/BandPower",...
"FRM_1/errVel_xTT_sigstats/ClearanceFactor","FRM_1/errVel_xTT_sigstats/CrestFactor","FRM_1/errVel_xTT_sigstats/ImpulseFactor","FRM_1/errVel_xTT_sigstats/Kurtosis","FRM_1/errVel_xTT_sigstats/Mean","FRM_1/errVel_xTT_sigstats/PeakValue","FRM_1/errVel_xTT_sigstats/RMS","FRM_1/errVel_xTT_sigstats/ShapeFactor","FRM_1/errVel_xTT_sigstats/Skewness","FRM_1/errVel_xTT_sigstats/Std","FRM_1/errVel_xTT_ps_spec/PeakAmp1","FRM_1/errVel_xTT_ps_spec/PeakAmp2","FRM_1/errVel_xTT_ps_spec/PeakFreq1","FRM_1/errVel_xTT_ps_spec/PeakFreq2","FRM_1/errVel_xTT_ps_spec/BandPower",...
"FRM_1/errVel_yTT_sigstats/ClearanceFactor","FRM_1/errVel_yTT_sigstats/CrestFactor","FRM_1/errVel_yTT_sigstats/ImpulseFactor","FRM_1/errVel_yTT_sigstats/Kurtosis","FRM_1/errVel_yTT_sigstats/Mean","FRM_1/errVel_yTT_sigstats/PeakValue","FRM_1/errVel_yTT_sigstats/RMS","FRM_1/errVel_yTT_sigstats/ShapeFactor","FRM_1/errVel_yTT_sigstats/Skewness","FRM_1/errVel_yTT_sigstats/Std","FRM_1/errVel_yTT_ps_spec/PeakAmp1","FRM_1/errVel_yTT_ps_spec/PeakAmp2","FRM_1/errVel_yTT_ps_spec/PeakFreq1","FRM_1/errVel_yTT_ps_spec/PeakFreq2","FRM_1/errVel_yTT_ps_spec/BandPower",...
"FRM_1/errVel_zTT_sigstats/ClearanceFactor","FRM_1/errVel_zTT_sigstats/CrestFactor","FRM_1/errVel_zTT_sigstats/ImpulseFactor","FRM_1/errVel_zTT_sigstats/Kurtosis","FRM_1/errVel_zTT_sigstats/Mean","FRM_1/errVel_zTT_sigstats/PeakValue","FRM_1/errVel_zTT_sigstats/RMS","FRM_1/errVel_zTT_sigstats/ShapeFactor","FRM_1/errVel_zTT_sigstats/Skewness","FRM_1/errVel_zTT_sigstats/Std","FRM_1/errVel_zTT_ps_spec/PeakAmp1","FRM_1/errVel_zTT_ps_spec/PeakAmp2","FRM_1/errVel_zTT_ps_spec/PeakFreq1","FRM_1/errVel_zTT_ps_spec/PeakFreq2","FRM_1/errVel_zTT_ps_spec/BandPower",...
"FRM_1/altitudeTT_sigstats/ClearanceFactor","FRM_1/altitudeTT_sigstats/CrestFactor","FRM_1/altitudeTT_sigstats/ImpulseFactor","FRM_1/altitudeTT_sigstats/Kurtosis","FRM_1/altitudeTT_sigstats/Mean","FRM_1/altitudeTT_sigstats/PeakValue","FRM_1/altitudeTT_sigstats/RMS","FRM_1/altitudeTT_sigstats/ShapeFactor","FRM_1/altitudeTT_sigstats/Skewness","FRM_1/altitudeTT_sigstats/Std","FRM_1/altitudeTT_ps_spec/PeakAmp1","FRM_1/altitudeTT_ps_spec/PeakAmp2","FRM_1/altitudeTT_ps_spec/PeakFreq1","FRM_1/altitudeTT_ps_spec/PeakFreq2","FRM_1/altitudeTT_ps_spec/BandPower", ...
"FRM_1/latitudeTT_sigstats/ClearanceFactor","FRM_1/latitudeTT_sigstats/CrestFactor","FRM_1/latitudeTT_sigstats/ImpulseFactor","FRM_1/latitudeTT_sigstats/Kurtosis","FRM_1/latitudeTT_sigstats/Mean","FRM_1/latitudeTT_sigstats/PeakValue","FRM_1/latitudeTT_sigstats/RMS","FRM_1/latitudeTT_sigstats/ShapeFactor","FRM_1/latitudeTT_sigstats/Skewness","FRM_1/latitudeTT_sigstats/Std","FRM_1/latitudeTT_ps_spec/PeakAmp1","FRM_1/latitudeTT_ps_spec/PeakAmp2","FRM_1/latitudeTT_ps_spec/PeakFreq1","FRM_1/latitudeTT_ps_spec/PeakFreq2","FRM_1/latitudeTT_ps_spec/BandPower", ...
"FRM_1/longitudeTT_sigstats/ClearanceFactor","FRM_1/longitudeTT_sigstats/CrestFactor","FRM_1/longitudeTT_sigstats/ImpulseFactor","FRM_1/longitudeTT_sigstats/Kurtosis","FRM_1/longitudeTT_sigstats/Mean","FRM_1/longitudeTT_sigstats/PeakValue","FRM_1/longitudeTT_sigstats/RMS","FRM_1/longitudeTT_sigstats/ShapeFactor","FRM_1/longitudeTT_sigstats/Skewness","FRM_1/longitudeTT_sigstats/Std","FRM_1/longitudeTT_ps_spec/PeakAmp1","FRM_1/longitudeTT_ps_spec/PeakAmp2","FRM_1/longitudeTT_ps_spec/PeakFreq1","FRM_1/longitudeTT_ps_spec/PeakFreq2","FRM_1/longitudeTT_ps_spec/BandPower", ...
"FRM_1/err_roll_TT_sigstats/ClearanceFactor","FRM_1/err_roll_TT_sigstats/CrestFactor","FRM_1/err_roll_TT_sigstats/ImpulseFactor","FRM_1/err_roll_TT_sigstats/Kurtosis","FRM_1/err_roll_TT_sigstats/Mean","FRM_1/err_roll_TT_sigstats/PeakValue","FRM_1/err_roll_TT_sigstats/RMS","FRM_1/err_roll_TT_sigstats/ShapeFactor","FRM_1/err_roll_TT_sigstats/Skewness","FRM_1/err_roll_TT_sigstats/Std","FRM_1/err_roll_TT_ps_spec/PeakAmp1","FRM_1/err_roll_TT_ps_spec/PeakAmp2","FRM_1/err_roll_TT_ps_spec/PeakFreq1","FRM_1/err_roll_TT_ps_spec/PeakFreq2","FRM_1/err_roll_TT_ps_spec/BandPower",...
"FRM_1/err_airspeed_TT_sigstats/ClearanceFactor","FRM_1/err_airspeed_TT_sigstats/CrestFactor","FRM_1/err_airspeed_TT_sigstats/ImpulseFactor","FRM_1/err_airspeed_TT_sigstats/Kurtosis","FRM_1/err_airspeed_TT_sigstats/Mean","FRM_1/err_airspeed_TT_sigstats/PeakValue","FRM_1/err_airspeed_TT_sigstats/RMS","FRM_1/err_airspeed_TT_sigstats/ShapeFactor","FRM_1/err_airspeed_TT_sigstats/Skewness","FRM_1/err_airspeed_TT_sigstats/Std","FRM_1/err_airspeed_TT_ps_spec/PeakAmp1","FRM_1/err_airspeed_TT_ps_spec/PeakAmp2","FRM_1/err_airspeed_TT_ps_spec/PeakFreq1","FRM_1/err_airspeed_TT_ps_spec/PeakFreq2","FRM_1/err_airspeed_TT_ps_spec/BandPower",...
"FRM_1/aspd_error_TT_sigstats/ClearanceFactor","FRM_1/aspd_error_TT_sigstats/CrestFactor","FRM_1/aspd_error_TT_sigstats/ImpulseFactor","FRM_1/aspd_error_TT_sigstats/Kurtosis","FRM_1/aspd_error_TT_sigstats/Mean","FRM_1/aspd_error_TT_sigstats/PeakValue","FRM_1/aspd_error_TT_sigstats/RMS","FRM_1/aspd_error_TT_sigstats/ShapeFactor","FRM_1/aspd_error_TT_sigstats/Skewness","FRM_1/aspd_error_TT_sigstats/Std","FRM_1/aspd_error_TT_ps_spec/PeakAmp1","FRM_1/aspd_error_TT_ps_spec/PeakAmp2","FRM_1/aspd_error_TT_ps_spec/PeakFreq1","FRM_1/aspd_error_TT_ps_spec/PeakFreq2","FRM_1/aspd_error_TT_ps_spec/BandPower",...
"FRM_1/alt_error_TT_sigstats/ClearanceFactor","FRM_1/alt_error_TT_sigstats/CrestFactor","FRM_1/alt_error_TT_sigstats/ImpulseFactor","FRM_1/alt_error_TT_sigstats/Kurtosis","FRM_1/alt_error_TT_sigstats/Mean","FRM_1/alt_error_TT_sigstats/PeakValue","FRM_1/alt_error_TT_sigstats/RMS","FRM_1/alt_error_TT_sigstats/ShapeFactor","FRM_1/alt_error_TT_sigstats/Skewness","FRM_1/alt_error_TT_sigstats/Std","FRM_1/alt_error_TT_ps_spec/PeakAmp1","FRM_1/alt_error_TT_ps_spec/PeakAmp2","FRM_1/alt_error_TT_ps_spec/PeakFreq1","FRM_1/alt_error_TT_ps_spec/PeakFreq2","FRM_1/alt_error_TT_ps_spec/BandPower",...
"FRM_1/err_yaw_TT_sigstats/ClearanceFactor","FRM_1/err_yaw_TT_sigstats/CrestFactor","FRM_1/err_yaw_TT_sigstats/ImpulseFactor","FRM_1/err_yaw_TT_sigstats/Kurtosis","FRM_1/err_yaw_TT_sigstats/Mean","FRM_1/err_yaw_TT_sigstats/PeakValue","FRM_1/err_yaw_TT_sigstats/RMS","FRM_1/err_yaw_TT_sigstats/ShapeFactor","FRM_1/err_yaw_TT_sigstats/Skewness","FRM_1/err_yaw_TT_sigstats/Std","FRM_1/err_yaw_TT_ps_spec/PeakAmp1","FRM_1/err_yaw_TT_ps_spec/PeakAmp2","FRM_1/err_yaw_TT_ps_spec/PeakFreq1","FRM_1/err_yaw_TT_ps_spec/PeakFreq2","FRM_1/err_yaw_TT_ps_spec/BandPower",...
"FRM_1/err_pitch_TT_sigstats/ClearanceFactor","FRM_1/err_pitch_TT_sigstats/CrestFactor","FRM_1/err_pitch_TT_sigstats/ImpulseFactor","FRM_1/err_pitch_TT_sigstats/Kurtosis","FRM_1/err_pitch_TT_sigstats/Mean","FRM_1/err_pitch_TT_sigstats/PeakValue","FRM_1/err_pitch_TT_sigstats/RMS","FRM_1/err_pitch_TT_sigstats/ShapeFactor","FRM_1/err_pitch_TT_sigstats/Skewness","FRM_1/err_pitch_TT_sigstats/Std","FRM_1/err_pitch_TT_ps_spec/PeakAmp1","FRM_1/err_pitch_TT_ps_spec/PeakAmp2","FRM_1/err_pitch_TT_ps_spec/PeakFreq1","FRM_1/err_pitch_TT_ps_spec/PeakFreq2","FRM_1/err_pitch_TT_ps_spec/BandPower"

];
featureTable = readFeatureTable(outputEnsemble,"FRM_1",'Features',selectedFeatureNames,'ConditionVariables',outputEnsemble.ConditionVariables,'IncludeMemberID',true);

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = unique([outputEnsemble.DataVariables;outputEnsemble.ConditionVariables;outputEnsemble.IndependentVariables],'stable');

% Gather results into a table.
outputTable = readall(outputEnsemble);
end
